package io.amient.crawler.service

import java.net.URI

import io.amient.crawler.HTMLGenerators
import org.scalacheck.Gen._
import org.scalatest.prop.PropertyChecks
import org.scalatest.{Matchers, PropSpec}

import scala.util.control.NonFatal

/**
  * Property-based test - we define properties that we require from content processor and let
  * the properties be tested over a larger randomly generated data.
  *
  * For example in the first two tests we are looking at hashing power of the processor. The
  * first property states that different hash must have been generated by a different object.
  * Same object can never produce 2 different hashes. Conversely, the property doesn't hold.
  * There can be collisions but they should be rare and we'll check that out of any 100 randomly
  * generated document sets, at most 1 collision occurs - which is still quite a large proportion
  * but we don't want the test to take several minutes to test millions of docs. The property tests
  * that the hashing function, say after refactoring, is not completely broken and unerliable.
  */
class ScannerPropSpec extends PropSpec with PropertyChecks with Matchers with HTMLGenerators {

  val scanner = new LocalScanner(this.getClass.getResource("/testsite/"))

  property("different-hash-must-be-different-object") {
    forAll { (doc1: Doc, doc2: Doc) =>
      whenever(scanner.computeHash(doc1) != scanner.computeHash(doc2)) {
        doc1 should not equal (doc2)
      }
    }
  }

  property("hash-collisions-are-rare") {
    val requiredSampleSize = 100
    val minHashSpaceSize = (requiredSampleSize * 0.99).toInt
    forAll(listOfN(requiredSampleSize, docs)) { sample =>
      sample.size should equal(requiredSampleSize)
      val hashSet = sample.map(doc => scanner.computeHash(doc)).toSet
      hashSet.size should be >= minHashSpaceSize
    }
  }

  property("urls-mapping-is-robust") {
    forAll(domains, paths, queries, urls) { (docDomain, docPath, docQuery, relUrl) =>
      whenever(!docDomain.startsWith("//") && !relUrl.startsWith("http")) {
        val docUri = new URI(docDomain + docPath + docQuery)
        try {
          val resUrl = scanner.linkToAbsoluteURL(docUri, relUrl).toString
          resUrl.endsWith("//") should not be(true)
          if (!relUrl.startsWith("//")) {
            resUrl.toString.endsWith(relUrl) should be(true)
            resUrl.startsWith(docDomain) should be(true)
          }
        } catch {
          case NonFatal(e) =>
            System.err.println((docDomain, docPath, docQuery))
            System.err.println(relUrl)
        }
      }
    }
  }

  property("url") {
    println(scanner.linkToAbsoluteURL(
      new URI("file:/Users/mharis/git/iocrawler/build/resources/test/testsite/"),
      "/contact.html"
    ))
  }

}